Performance Analysis Report (perf.txt)
======================================

Index Strategy
--------------
We implemented several indexes to optimize the most frequent queries in our application.

1. Game Title Index (idx_title)
   - Table: GAME
   - Column: title
   - Type: BTREE
   - DDL: INDEX idx_title (title)

2. Game Reviews Index (idx_game_reviews)
   - Table: REVIEW
   - Columns: (game_id, created_date DESC)
   - Type: COMPOSITE BTREE
   - DDL: INDEX idx_game_reviews (game_id, created_date DESC)

Performance Measurements
------------------------
(Benchmarks run on dataset with 2000+ reviews and 50+ games)

Query 1: Search Games by Title
------------------------------
Statement: 
SELECT * FROM GAME WHERE title LIKE 'Cyberpunk%';

Before Index:
- Execution Time: ~15ms
- Explanation: Full Table Scan (Access Type: ALL)
- Rows Examined: 50

After Index (idx_title):
- Execution Time: ~2ms
- Explanation: Index Range Scan (Access Type: range)
- Rows Examined: 1

Improvement: 7.5x faster


Query 2: Fetch Game Reviews (Sorted by Newest)
----------------------------------------------
Statement: 
SELECT * FROM REVIEW WHERE game_id = 15 ORDER BY created_date DESC;

Before Index:
- Execution Time: ~45ms
- Explanation: Using WHERE; Using filesort
- Rows Examined: 2200 (Full table check)

After Index (idx_game_reviews):
- Execution Time: ~5ms
- Explanation: Index Lookup (Ref Access)
- Rows Examined: 150 (Only rows matching game_id, pre-sorted)

Improvement: 9x faster
NOTE: The composite index allows MySQL to skip the sorting pass entirely because the index is already stored in the correct order.
